---
utid: 1000-03-05
chapter: 03
chaptername: فصل سوم: شروع واقعی با دیتابیس
part: 05
title: جدول‌هایی برای آپولو
_index: apollo-tables
---

در درس‌های قبل این فصل، که همگی به کار با دیتابیس اختصاص داشتند، پیکربندی دیتابیس را آموختیم و سپس با مفهوم مایگرشن آشنا شدیم و اصول اولیه ساخت و ویرایش جدول‌ها به کمک آن را فرا گرفتیم و دانستیم که چطور می‌توانیم به لطف مایگرشن، فرآیند ایجاد و مدیریت ساختار جدول‌های اطلاعاتی خود را به محیط کدنویسی برنامه بیاوریم و چتر سیستم کنترل نسخه‌ی خود را بر آن بیافکنیم.

در این درس برای نخستین بار به طور جدی سراغ آپولو هوا کردنمان می‌رویم و از آنجا که شروع پروژه‌ها همیشه با تعریف و راه‌اندازی دیتابیس آغاز می‌شود، این پروژه را نیز با ساخت جدول‌ها کلید می‌زنیم.

# یک شروع تمیز

بد نیست حالا که می‌خواهیم دست به کد شویم، همه چیز را از صفر شروع کنیم؛ یعنی از نقطه‌ای که پیکربندی دیتابیس را انجام داده‌ایم، ولی هنوز هیچ مایگرشنی ننوشته‌ایم.

اگر برای تمرین مایگرشنی نوشته‌اید و اجرا کرده‌اید، دیتابیس و فایل‌هایی که ساخته‌اید را به صورت دستی پاک کنید. 

بهتر است محض اطمینان، از کامپوزر بخواهید تا یک بار فهرست فایل‌های Autoload را به‌روزرسانی کند. برای این کار، دستور زیر را در کنسول خط فرمان خود اجرا کنید.

```bash
composer dump-autoload
```

# جدولی برای مأموریت‌های فضایی

اولین جدولی که می‌سازیم، جدولی‌ست که اطلاعات مأموریت‌های فضایی را در آن نگهداری می‌کنیم.

شما اکنون می‌دانید که برای ساخت مایگرشن مربوط به این جدول، به چه دستور آرتیزانی نیاز داریم.

```bash
php artisan make:migration create_missions_table
```

و می‌دانید که با اجرای این دستور، لاراول کلاسی برای ما می‌سازد و بدنه‌ی آن را تکمیل می‌کند. 

اجازه بدهید با این پیش‌فرض که همراه من جلو می‌آیید و کارهایی که می‌گویم را واقعاً انجام می‌دهید، از نمایش تصویر اسکرین‌شات از اجرای دستور بالا در کنسول خط فرمان و کد تولیدشده، صرف نظر کنم و سراغ اصل مطلب برویم.

## چه ستون‌هایی لازم داریم؟

این اولین پرسشی‌ست که هنگام طراحی یک جدول با آن مواجه می‌شویم، اما اولین پرسشی نیست که باید جوابش را بیابیم. سؤال درست در این مرحله، چیز دیگری است:

#### چه داده‌هایی را قرار است نگهداری کنیم؟

- کد مأموریت
- عنوان مأموریت 
- سازمان مسئول
- هدف از اجرا
- شرح کوتاه
- تاریخ آغاز
- تاریخ پایان
- وضعیت تصویب
- وضعیت اجرایی
- فضانوردان شرکت‌کننده
- کارکنان مرکز کنترل
- اسناد و مدارک و عکس‌های یادگاری

## حالا چه ستون‌هایی لازم داریم؟

بله. حالا که می‌دانیم چه داده‌هایی را قرار است برای یک مأموریت نگهداری کنیم، می‌توانیم به ستون‌ها فکر کنیم.

- یک ستون افزایش خودکار، به عنوان ایندکس اولیه که گفتیم همیشه نامش را `id` می‌گذاریم و همیشه در ابتدای هر جدول قرار می‌دهیم؛
- ستون‌هایی از نوع متن، برای نگهداری کد و عنوان مأموریت و سازمان مسئول و هدف و شرح کوتاه؛
- ستون‌هایی از نوع تاریخ برای نگهداری زمان آغاز و پایان رسمی مأموریت؛
- ستونی از نوع منطقی برای این که بدانیم مأموریت مورد نظر ما به تصویب مقامات رسیده است یا خیر؛
- ستونی برای نگهداری وضعیت اجرایی

### وضعیت اجرایی

این ستون وضعیت اجرایی کمی دردسرساز است. کارفرما می‌گوید که وضعیت اجرایی یکی از حالت‌های «در حال برنامه‌ریزی»، «در حال اجرا»، «موفقیت‌آمیز» و «شکست‌خورده» است و چیزی جز این چهار حالت وجود ندارد. پس ما می‌توانیم یک ستون متنی برای وضعیت در نظر بگیریم و یکی از همین چهار حالت را در آن ذخیره کنیم.

اما راه بهتری هم وجود دارد. به ازای هر کدام از این چهار وضعیت، یک ستون مستقل از نوع زمان در نظر می‌گیریم و تاریخ و ساعت وقوع هر یک از این وضعیت‌ها را در آن ثبت می‌کنیم:

- زمان شروع برنامه‌ریزی
- زمان شروع اجرا
- زمان پایان موفقیت‌آمیز
- زمان شکست

طبیعتاً یک مأموریت نمی‌تواند هم موفقیت‌آمیز باشد و هم شکست‌خورده تلقی شود و یکی از دو ستون پر می‌شود و به دیگری نیازی نیست. فعلاً نگران این موضوع نباشید و به این فکر کنید که تفکیک وضعیت اجرایی به چهار ستون زمانی، ما را دست از ستون‌های مبهم آغاز و پایان نیز خلاص می‌کند.

### ضمیمه‌های جدول

نگهداری نام اشخاص دخیل در مأموریت، و همچنین گزارش‌ها و عکس‌های یادگاری در ستون‌های جدول مأموریت‌ها فکر خوبی نیست. بهتر است اطلاعات آن‌ها را در جداولی جداگانه نگهداری کنیم و سپس به این جدول متصل نماییم.

## متد بالارونده

حالا می‌توانیم دست به کیبورد شویم و کد آنچه را که لازم داریم، بنویسیم. در متد بالارونده، موسوم به `up`، ترتیب برپا کردن جدول را می‌دهیم.

کد متد `up` شما باید چیزی به شکل زیر شود، هرچند می‌دانید که همه‌ی این کد را لازم نیست خودتان بنویسید. کنسول آرتیزان بخش‌هایی را از قبل برای شما نوشته بود.

```php
public function up()
{
    Schema::create('missions', function (Blueprint $table) {
        $table->increments('id');
        $table->string('code')->index();
        $table->string('title')->index();
        $table->string('operator')->index();
        $table->mediumText('purpose')->nullable();
        $table->text('description')->nullable();
        $table->boolean('is_ratified')->default(false);
        $table->timestamp('planned_at')->nullable()->index();
        $table->timestamp('started_at')->nullable()->index();
        $table->timestamp('succeeded_at')->nullable()->index();
        $table->timestamp('failed_at')->nullable()->index();
        $table->timestamps();
        $table->softDeletes();
    });
}
```

پیش از آن که به خواندن ادامه دهید، کمی تأمل کنید و سعی کنید تک‌تک خط‌های قطعه کد بالا را برای خود تفسیر کنید که هر کدام چه می‌کنند.

ما در این کد، علاوه بر آنچه که بالاتر برنامه‌ریزی کردیم، جزئیات دیگری را هم رعایت کردیم.

- تمام ستون‌هایی که به نظر می‌رسید ممکن است به مرتب‌سازی و جست‌وجو نیاز داشته باشند را با استفاده از متد زنجیره‌ای `()index` کردیم.
- تمام ستون‌هایی که به نظر می‌رسید ممکن است اختیاری باشند را با استفاده از متد زنجیره‌ای `()nullable` متمایز ساختیم تا غیبت اطلاعات، ما را با مشکلی مواجه نکند.
- ستون منطقی وضعیت تصویب را به کمک متد زنجیره‌ای `()default` با یک مقدار پیش‌فرض پر کردیم.
- به کمک متد `()timestamps` دو ستون برای نگهداری زمان ایجاد و آخرین به‌روزرسانی هر رکورد اضافه کردیم تا لاراول، خودش، ترتیب بقیه‌ی کارها را بدهد.
- به کمک متد `()softDeletes` ستونی به نام `deleted_at` برای ایجاد قابلیت زباله‌دان ایجاد کردیم.

اجرای این مایگرشن در دیتابیس mySql، باید جدولی به این شکل برای شما ایجاد کند.

![Missions Table Structure](/laravel-0-to-60/images/migration-missions-structure.jpg)

## متد پایین‌رونده

یادتان هست که در متد پایین‌رونده باید چه می‌کردیم؟ 

هر آنچه در متد `up` ساخته شده، می‌بایست در متد ‍`down` از بین برود تا عملکرد عقبگرد در مایگرشن به‌خوبی انجام شود.

متد بالارونده‌ی جدول مأموریت‌های ما، جدول را برپا ساخته بود و متد پایین‌رونده باید آن را نابود کند.

```php
public function down()
{
    Schema::dropIfExists('missions');
}
```

اگر با من جلو آمده باشید، متوجه شده‌اید که این خط‌ها از قبل توسط آرتیزان نوشته شده بودند!

# جدولی برای اطلاعات آدم‌ها

از آنجا که تقریباً تمام پروژه‌های وب که در عالم امکان وجود دارند، جدولی برای نگهداری اطلاعات کاربران نیاز دارند، لاراول مایگرشن ساده‌ای برای جدول `users` را در جعبه‌ی خود گذاشته که در بدو نصب، قابل استفاده است. 

متد `up` این مایگرشن از پیش آماده شده، به شکل زیر است:

```php
public function up()
{
    Schema::create('users', function (Blueprint $table) {
        $table->increments('id');
        $table->string('name');
        $table->string('email')->unique();
        $table->string('password');
        $table->rememberToken();
        $table->timestamps();
    });
}
```

به دستور ساخت ستون `id` در ابتدای کد، و متد `()timestamps` در انتهای آن توجه کنید و به خاطر بسپارید که در مایگرشن‌هایی که خودتان هم می‌نویسید این الگو را رعایت کنید تا ساختار دیتابیسی یکپارچه و استاندارد داشته باشید.

ستونی که با متد `()rememberToken‍` ساخته می‌شود، رشته‌ای صد کاراکتری در خود جای می‌دهد که به درد گزینه‌ی «مرا به خاطر بسپار» زیر فرم‌های لاگین می‌خورد و لاراول، خودش ترتیب استفاده از آن را می‌دهد. 

## ستون‌های مورد نیاز ما

ما برای آپولو هوا کردنمان، به تعدادی ستون دیگر هم نیاز داریم و هیچ اشکالی ندارد که آن‌ها را لابه‌لای همین ستون‌های پیش‌فرض، و در همین فایل مایگرشنی که از قبل مهیا شده بود، قرار دهیم. اما حالا که می‌خواهیم چیزی یاد بگیریم، بد نیست یک مایگرشن ویرایشگر بسازیم و ستون‌های خودمان را در مایگرشن خودمان به جدول کاربران اضافه کنیم.

# جان کلام

جدول‌ها همیشه با اسامی جمع

تمام زمان‌ها nullable