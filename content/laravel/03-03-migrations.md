---
utid: 1000-03-03
chapter: 03
chaptername: فصل سوم: شروع واقعی با دیتابیس
part: 03
title: طراحی دیتابیس با مایگرشن
_index: migrations
---
مایگرشن‌ها اختراع لاراول نیستند و خیلی پیش از آن به وجود آمده‌اند.

لاراول، دنیایی است با ابزارهایی رنگ و وارنگ و اسم‌های جذاب، که اغلب از قبل وجود داشته‌اند و حیاتشان را مدیون لاراول نیستند، اما زیبایی در کنار هم بودنشان را چرا.

## فلسفه‌ی مایگرشن

کدهای برنامه‌ی خود را روی یکی از سیستم‌های کنترل ورژن مثل گیت نگه می‌داریم و خوشحالیم که اگر اتفاق ناگواری افتاد، به عقب بازمی‌گردیم و دقیقاً می‌دانیم هر تغییر چه تأثیری بر مخلوق ما داشته، اما دیتابیس ما از این قافله جداست.

مایگرشن برای همین روزها ساخته شده است!

داستان از این قرار است که ما باید دیتابیس خودمان را در یک برنامه و ابزار جداگانه بسازیم و مدیریت کنیم، و هر بار که می‌خواهیم فایل‌های پروژه را به کسی بدهیم، باید یک بکاپ دستی هم از دیتابیس بگیریم و برایش بفرستیم.

بهتر نبود تهیه‌ی زیرساخت‌های اطلاعاتی را هم می‌توانستیم در ویرایشگر کد خود انجام دهیم و طراحی دیتابیس هم مثل بقیه چیزها، همان جا باشد تا هم انتقالش به دیگران راحت باشد و هم تحت نظارت سیستم کنترل نسخه‌ی ما عمل کند؟

مایگریشن منطق ساده‌ای دارد.

الگوی دیتابیس خود را در جایی معرفی می‌کنیم، ایندکس‌ها و ارتباطات آن را با زبانی شبیه زبان آدمیزاد مشخص می‌کنیم، و فایل را که یک کلاس معمولی پی‌اچ‌پی است، لابه‌لای دیگر فایل‌های پروژه قرار می‌دهیم تا هم گیت کار خود را انجام دهد و هم ما بتوانیم با یک کپی ساده، کل پروژه را در اختیار دوست و همکار یا مشتریمان قرار دهیم.

## آماده‌های داخل جعبه

لاراول، درست بعد از نصب، دو فایل مایگرشن حاضر و آماده به استفاده در خود دارد که در پوشه‌ای به نام migrations در پوشه‌ی database قرار دارند:

	2014_10_12_000000_create_users_table
	2014_10_12_100000_create_password_resets_table

اجازه دهید نگاهی به این فایل‌ها بیاندازیم و ببینیم چه دستگیرمان می‌شود.

#### الگوی نام‌گذاری

نام‌ها به اندازه‌ی کافی گویا هست. اولی جدولی برای نگهداری اطلاعات کاربران می‌سازد و دومی جدولی برای فراموشی رمزهای عبور. شما هم چنین نام‌هایی انتخاب کنید تا فایل‌هایتان به‌راحتی قابل شناسایی باشند.

در بخش اول نام هر دو فایل، الگوی یک تاریخ و یک عدد قابل تشخیص است. لاراول از این‌ها برای ترتیب اجرای مایگرشن‌ها استفاده می‌کند. 

#### ساختار داخلی

فایل‌های مایگریشن، کلاس‌هایی هستند که از کلاس والدی به نام Migration نشأت گرفته‌اند و هر کدام دو متد دارند: یک متد up که طرح جدول را ترسیم می‌کند و یک متد down که برعکس کار متد up را، هرچه که باشد، انجام می‌دهد.

عنوان کلاس‌ها، صورت Studly Caps از همان نام فایل هستند.

#### فلسفه حضور

تقریباً تمام برنامه‌های وبی که در عالم واقع نوشته می‌شوند، بخشی برای لاگین کردن و ورود به پیشخوان کاربری دارند. لاراول ابزارهای لازم برای این کار را در جعبه‌اش گذاشته و این ابزارها، شامل مسیرهای لازم برای فرآیند لاگین و ثبت نام و فراموشی رمز عبور، فرم‌ها و کنترلر‌ها و البته مایگرشن‌ها هستند.

اگر جدول کاربران پروژه‌ی شما به چیزهایی بیش از این نیاز دارد، فایل را باز کرده و آن‌ها را تغییر دهید.

## عملکرد مایگرشن

برای اجرای مایگرشن‌ها از کنسول آرتیزان کمک می‌گیریم.

	php artisan migrate

با اولین اجرای این دستور، لاراول به سراغ پوشه‌ی مایگرشن‌ها می‌رود و فایل‌های موجود در آن را به ترتیب تاریخی که در ابتدای اسمشان هست، مرتب می‌کند و متد up آن‌ها را یکی‌یکی اجرا می‌کند و بعد از هر اجرا، نام مایگرشن اجراشده را در جدولی به نام migrations ذخیره می‌نماید.

طبیعتاً اگر چنین جدولی وجود نداشت، خودش آن را می‌سازد و شما لازم نیست نگران چیزی باشید. (یک بار دیگر نگاهی به فایل پیکربندی دیتابیس بیاندازید. نام این جدول به‌خصوص را می‌توانید تغییر دهید.)

اجرای دوباره‌ی دستور migrate در کنسول آرتیزان، دوباره فایل‌ها را به خط می‌کند و این بار فقط همان‌ها را اجرا می‌کند که دفعه‌ی قبل اجرا نشده باشند و در فاصله‌ی این دو اجرا به جمع مایگرشن‌ها پیوسته‌اند.

#### بازگشت به عقب

	php artisan migrate:rollback

با اجرای این دستور، لاراول فهرستی از آخرین گروه از مایگرشن‌های اجراشده را از همان جدولی که در بالا گفتیم تهیه می‌کند و به سراغ تک‌تکشان می‌رود و متد down موجود در آن‌ها را اجرا می‌کند. طبیعتاً این کار را با ترتیبی برعکس آنچه که وقت ایجاد لحاظ کرده بود انجام می‌دهد.

گفتیم متد down برعکس همان کاری را می‌کند که متد up انجام داده. اگر در متد up جدولی ساختیم، در متد down آن را نابود می‌کنیم و اگر در متد up چیزی را تغییر دادیم، در متد down تغییرات را به حالت اول بازمی‌گردانیم. 

اجرای مجدد دستور migrate:rollback، گروه مایگرشن بعدی را نیز به حالت قبل بازمی‌گرداند و این کار را می‌توانید آن قدر ادامه دهید که دیگر جدولی باقی نماند.

به صورت پیش‌فرض، با هر بازگشت یک لایه به عقب می‌روید، اما می‌توانید این روند را تغییر دهید.

	php artisan migrate:rollback --step=5

پارامتر دل‌خواه step، تعداد لایه‌هایی که می‌بایست به عقب بروند را تعیین ‌می‌کند.

#### بازگشت به ابتدا

	php artisan migrate:reset

این دستور، لاراول تمام مایگرشن‌های اجراشده را تا انتها به عقب برمی‌گرداند و چیزی به جز جدول migrations که برای کارهای خودش لازم دارد، باقی نمی‌گذارد. 

#### برپایی مجدد

	php artisan migrate:refresh

این دستور، همه‌ی جدول‌ها را از بین می‌برد و دوباره از نو می‌سازد و عملاً ترکیبی از دو دستور بازگشت به ابتدا، و اجرای دوباره است.

#### نوسازی کامل

	php artisan migrate:fresh

این دستور نیز مثل دستور قبلی همه‌ی جدول‌ها را از بین می‌برد و دوباره از نو می‌سازد، اما این کار را بدون فرآیند بازگشت انجام می‌دهد. به بیان فنی‌تر، همه‌ی جدول‌های موجود را بدون توجه به متدهای down موجود در مایگرشن‌ها، به یکباره drop می‌کند و سپس دوباره دستور migrate را اجرا می‌کند.

## چه بر سر داده‌ها می‌آید؟

اجرای مایگرشن، کاری نیست که معمولاً در فاز بهره‌برداری برنامه انجام شود و معمولاً همه چیز در فاز توسعه (چه برپایی و چه بهبود) صورت می‌گیرد. اما پرسش اساسی پابرجاست.

چه بر سر داده‌ها می‌آید؟

پاسخ این سؤال به کاری که می‌کنید بستگی دارد. اگر مایگرشنی نوشته‌اید که جدولی را از بین می‌برد، داده‌های آن هم از بین می‌روند. اگر دستوری مثل بازگشت یا نوسازی را صادر کنید، آن بخش از داده‌هایی که بستر آن‌ها را نابود می‌کنید، از بین می‌روند. اما اگر صرفاً جدول‌های جدیدی در پروژه ایجاد کرده‌اید و چیزهایی را تغییر داده‌اید، دستور migration به اطلاعات صدمه‌ای نمی‌زند.

توصیه می‌کنم حتی در همین مرحله از این درس نیز کتاب را کنار بگذارید و چند بار انواع و اقسام دستورهایی که در بالا گفتیم را آزمایش کنید و نتیجه را در برنامه‌هایی نظیر phpMyAdmin ببینید. خطری ندارد و در بدترین حالت، می‌توانید همه جدول‌های ایجادشده را دستی پاک کنید و دوباره با جریان کتاب همراه شوید.

## ایجاد فایل مایگریشن

اگر هنگام مطالعه‌ی ساختار مایگرشن‌های موجود در داخل جعبه‌ی لاراول دچار این ترس شدید که باید نام فایل را درست انتخاب کنید و تاریخ را به فرمتی قابل درک برای لاراول در ابتدایش قرار دهید و بعد هم کلاسی بسازید و متدهایی را طبق برنامه در آن بگذارید، نگران نباشید.

مشکلات لاراولی راه‌حل‌هایی لاراولی دارند و کنسول آرتیزان برای همین کارها ساخته شده.

	php artisan make:migration create_vessels_table

این دستور، فرمت تاریخی درست را متناسب با زمان اجرای دستور، در ابتدای نامی که خواسته‌ایم می‌نهد و فایلی را در جای درست می‌سازد و نامش را به ما می‌گوید:

![](_images/03-03-01.png)

کار به همین جا ختم نمی‌شود و لاراول، کلاس و متدهای داخل فایل تازه را نیز تعریف می‌کند و تنها کاری که باقی می‌ماند این است که دستورهایی که می‌خواهیم را برای دو متد up و down آن تعریف کنیم.

خودتان امتحان کنید. حاصل دستور بالا، فایلی است به این شکل:

``` php
<?php // 2018_01_12_181239_create_vessels_table
  use Illuminate\Support\Facades\Schema;
  use Illuminate\Database\Schema\Blueprint;
  use Illuminate\Database\Migrations\Migration;
  class CreateVesselsTable extends Migration
  {
  /**
  *Run the migrations.
  *@return void
  */
    public function up()
    {
      Schema::create('vessels', function (Blueprint $table) {
      $table->increments('id');
      $table->timestamps();
    });
  }
  /**
  * Reverse the migrations.
  * @return void
  */
    public function down()
    {
      Schema::dropIfExists('vessels');
    }
  }
```

 همان طور که ملاحظه می‌فرمایید، حتی درون متدهای up و down را نیز تا حدودی که حدس می‌زده چه می‌خواهیم بکنیم، پر کرده است و فقط باید زحمت بکشیم و دستور اضافه کردن فیلدهایی که می‌خواهیم، در متد up بنویسیم  و ساختار موجود را تکمیل کنیم.

## کار با جدول‌ها

هر کاری که در مایگرشن انجام می‌شود، در واقع روی یکی از جدول‌های بانک اطلاعاتی ما انجام می‌شود. این کارها از سه حالت خارج نیستند: یا می‌خواهیم جدولی را بسازیم، یا تغییراتی در آن ایجاد کنیم، و یا حذف نماییم.

در این میان، دستوراتی که برای حذف و تغییر نام جدول‌ها به کار می‌روند، سرراست‌تر و ساده‌تر هستند:

	Schema::rename($from, $to);
	Schema::drop('vessels');
	Schema::dropIfExists('vessels');

کلاس اسکیما[^c030301] (Schema) به صورت پیش‌فرض در بخش dependencyهای بالای فایل خوانده شده و به عنوان ابزار تغییرات در فایل مایگرشن مورد استفاده قرار می‌گیرد. ما فعلا به نحوه‌ی عملکرد آن کاری نداریم و روی متدهای استاتیکی که در اختیارمان می‌گذارند تمرکز می‌کنیم.

[^c030301]: به دلیل محدودیت زبان فارسی، چاره‌ای جز نوشتن این کلمه به صورت «اسکیما» نداریم، اما شما هنگام خواندن، الف ابتدای آن را تا جای ممکن نادیده بگیرید و روی حرف سین، یک سکون بگذارید: «سْکیما»

متد نخست نام جدول را تغییر می‌دهد، متد دوم جدول را پاک می‌کند، و متد سوم جدولی را در صورتی که وجود داشت پاک می‌کند. پیشنهاد می‌کنم در متدهای down خود، هنگامی که می‌خواهید جدولی را پاک کنید، از حالت سوم استفاده کنید تا اگر جدول به هر دلیلی قبلاً پاک شده بود یا وجود نداشت، کد شما بدون مشکل اجرا شود.

دستورهای ایجاد جدول و تغییرات، پارامتر دومی را به صورت closure دریافت می‌کنند که ماهیت تغییرات را مشخص می‌کند.

	Schema::create('vessels' , function (Blureprint $table) {});
	Schema::table('vessels' , function (Blureprint $table) {});

الگوی کار به این نحو است که شیئی به نام $table از نوع Blueprint، که به صورت پیش‌فرض در بخش dependencyهای بالای فایل معرفی شده، را به داخل closure می‌فرستیم و سایر عملیات را با آن انجام می‌دهیم که در ادامه‌ی این درس مورد بررسی قرار می‌گیرند.

همان طور که دیدیم، دستورهای ساخت مایگرشن در کنسول آرتیزان، این الگوها را نیز ایجاد می‌کند و تنها کاری که لازم است انجام دهیم، آن است که فیلدها و تغییرات مورد نظر خود را درون این closureها بنویسیم.

## تعریف ستون‌ها

ساده‌ترین کار در فرآیند ساخت مایگریشن‌ها، ایجاد ستون‌هاست. Blueprint متدهای متنوعی با نام هر یک از انواع داده تحت حمایت بیشتر دیتابیس‌ها در اختیار ما می‌گذارد که به عنوان پارامتر نخست، نام ستون را دریافت می‌کنند.

#### ستون افزایش خودکار

مرسوم است که نخستین ستون هر جدول را id می‌نامند و در حالت افزایش خودکار قرار می‌دهند و primary-index جدول را روی آن تنظیم می‌کنند. متدهای زیر همین کار را به روش‌های مختلف انجام می‌دهند.

	$table->increments('id');
	$table->bigIncrements('id');
	$table->mediumIncrements('id')
	$table->smallIncrements('id');
	$table->tinyIncrements('id');

در قریب به اتفاق برنامه‌هایی که می‌نویسیم از همان نخستین متد استفاده می‌کنیم و لاراول هم که متوجه این موضوع هست، در دستورات مایگریشن‌ساز لاراول، از این متد استفاده می‌کند. به فایل ساخت جدول vessels که با هم ساختیم و فایلی که لاراول خودش ساخته بود و در جعبه گذاشته بود نگاه کنید و کاربرد این متد را در نخستین خط جدول اسکیما ببینید.

#### ستون‌های عددی

متدهای زیر برای تعریف ستون‌های عدد صحیح به کار می‌روند که هر کدام محدوده و بازه‌ای از اعداد را تحت پوشش قرار می‌دهند که موضوع بحث این کتاب نیست.

	$table->integer('age');
	$table->smallInteger('age');
	$table->mediumInteger('age');
	$table->bigInteger('age');
	$table->unsignedInteger('age');
	$table->unsignedSmallInteger('age');
	$table->unsignedMediumInteger('age');
	$table->unsignedTinyInteger('age');

متدهای زیر برای تعریف اعداد اعشاری به کار می‌روند. پارامتر دوم تعداد کل ارقام و پارامتر سوم تعداد ارقام بخش اعشار را مشخص می‌کنند.

	$table->decimal('amount', 8, 2);
	$table->double('amount', 8, 2);
	$table->float('amount', 8, 2);

اگرچه نوع داده‌ی BOOLEAN در بیشتر انواع رایج دیتابیس تعریف شده، در mySql چنانچه مرسوم است از TINYINT برای ذخیره‌ی مقدارهای منطقی استفاده می‌کنند. Blueprint دستوری برای boolean دارد، اما همچنان برای ساخت جدول در mySql از TINYINT بهره می‌گیرد. 

با این حال، بهتر است برای خوانا شدن کد و هماهنگی با سایر دیتابیس‌ها، برای متغیرهای منطقی خود از متدی که برای همین کار در اختیار ماست استفاده کنیم و تصمیم را به عهده‌ی لاراول بگذاریم تا با توجه به دیتابیس ما، بهترین انتخاب را انجام دهد.

	$table->boolean('active')

#### رشته و متن

متدهای زیر برای تعریف ستون‌های رشته‌ای، با طول دلخواه به کار می‌روند. اولی همان طور که از نامش پیداست، ستونی با نوع CHAR تشکیل می‌دهد و دومی VARCHAR می‌سازد و از آنجا که استفاده از آن متداول‌تر است، لاراول عبارت انگلیسی زیباتری را برای آن برگزیده تا به خوانایی کد کمک کند.

	$table->char('name', 100);
	$table->string('name', 100);

سه متد زیر که برای ذخیره‌سازی متن به کار می‌روند، به ترتیب منطبق بر نوع داده‌های TEXT، MEDIUMTEXT و LONGTEXT در دیتابیس‌ها هستند که بنا بر مستندات mySql، اولی ۶۴ کیلوبایت، دومی ۱۶ مگابایت، و سومی ۴ گیگابایت ظرفیت دارد. 

	$table->text('description');
	$table->mediumText('description');
	$table->longText('description');

#### نگهداری زمان

هر کدام از متدهای زیر،‌ معادل نوع داده‌ای متناظر با همان نام در دیتابیس هستند که برای نگهداری زمان، یا تاریخ و زمان به کار می‌روند.

خواننده‌ی این کتاب می‌داند که برای ذخیره‌ی تاریخ‌های جلالی نیز بهتر است زمان را با فرمت استاندارد میلادی ثبت کند و تبدیل تاریخ را در مرحله‌ی نمایش به کاربر انجام دهد و نیازی به اشاره‌ی من نیست.

	$table->time('sunrise');
	$table->timeTz('sunrise');
	$table->timestamp('added_on');
	$table->timestampTz('added_on');
	$table->year('birth_year');
	$table->dateTime('created_at');
	$table->dateTimeTz('created_at');

#### زمان‌های مهم

سیستم مدیریت مدل‌های لاراول (موسوم به الیکوئنت)، زمان اضافه شدن و آخرین به‌روزرسانی رکوردها را به صورت پیش‌فرض ثبت می‌کند و برای این کار به دو ستون created_at و updated_at نیاز دارد.

	$table->timestamp('created_at')->nullable();
	$table->timestamp('updated_at')->nullable();

اما در زمان اضافه تعریف مایگرشن نیازی به درج این دو خط و متد عجیب و غریب nullable() که تاکنون صحبتی از آن نکرده‌ایم، نیست. لاراول متد به‌خصوصی برای این کار دارد تا فیلدهای مورد نیاز خودش را اضافه کند.

	$table->timestamps();

با همین یک دستور که در انتهای فیلدهای خودتان قرار می‌دهید، از لاراول می‌خواهید ترتیب ثبت آن دو ستون دلخواه خود را نیز بدهد.

#### ستون زباله‌دان

سیستم‌عامل‌های متداول دسکتاپ، فایل‌هایی که پاک می‌کنیم را به زباله‌دان منتقل می‌کنند و تا وقتی آن‌ها را از زباله‌دان هم حذف نکنیم، کاری به کارش ندارند. در واقع فرمان پاک کردن فایل‌ها در این سیستم‌های عامل، فایل‌ها را موقتاً از دسترس ما دور می‌کنند و بس.
در برنامه‌های وبی که ما می‌نویسیم نیز این قابلیت به کار می‌آید. کاربران برنامه رکوردی را پاک می‌کنند و بعد پشیمان می‌شوند و اگر ما واقعاً پاک کرده باشیم دیگر کمکی از دستمان برنمی‌آید.

راه انداختن یک سیستم زباله‌دان در جدول‌های اطلاعاتی کار سختی نیست، اما ظرایفی دارد که باید مراقبشان باشیم. فریمورک قدرتمند لاراول با پشتیبانی از این قابلیت، کار ما را ساده می‌کند.

در مرحله‌ی تولید مایگرشن، تنها کاری که باید بکنیم ایجاد ستونی برای این کار است.

	$table->softDeletes();

با این کار، یک فیلد قابل null شدن به نام deleted_at در جدول اضافه می‌شود.

## ریزه‌کاری‌های دیگر

برای آن که مشخص کنیم ستون مورد نظر ما می‌تواند مقدار null را بپذیرد، از متد nullable() در انتهای همان دستور ایجاد ستون استفاده می‌کنیم:

	$table->string('email')->nullable();

و به همین ترتیب، متد default() برای درج مقدار پیش‌فرض:

	$table->boolean('active')->default(true);

و متد comment() برای درج کامنت:

	$table->string('email')->comment('This is Email');

برای آن که زمان فعلی را به عنوان پیش‌فرض یک ستون زمانی تعیین کنیم:

	$table->string('created_at')->useCurrent();

برای آن که کدبندی نویسه را به چیزی غیر از پیش‌فرض دیتابیس تغییر دهیم:

	$table->charset('utf8')

یا تغییر collation:

	$table->collation('utf8_persian_ci')

از همه جالب‌تر این که این متدهای زنجیره‌ای را می‌توانید به دنبال هم و بدون ترتیب مشخص وارد نمایید:

	$table->string('email')->nullable()->comment('folan')->charset('utf8')

## ایندکس‌ها

ایندکس‌گذاری درست در طراحی یک جدول، تأثیر مستقیم و بسیار مهمی در بازدهی و عملکرد برنامه دارد. اسکیما، موتور جدول‌سازی لاراول، انواع و اقسام ایندکس‌ها را پشتیبانی می‌کند و راه‌های مختلفی برای تعریف آن‌ها ارائه می‌کند.

#### ایندکس معمولی

در همان خطی که ستون را تعریف کردید، می‌توانید متد index را نیز به صورت زنجیره‌ای فرا بخوانید و با این کار از لاراول بخواهید ایندکسی را برای آن ستون تعریف کند.

	$table->string('name')->index();

به جای این کار، ایندکس را می‌توانید پس از تعریف یک ستون نیز در خطی مستقل تعیین کنید.

	$table->index('name')

همین متد بالا می‌تواند به جای نام یک ستون، آرایه‌ای از نام‌های چند ستون مختلف بگیرد و ایندکسی مرکب بسازد.

	$table->index(['last_name','first_name']);

لاراول به صورت پیش‌فرض نام خوبی برای ایندکس‌هایمان می‌گذارد، اما اگر دوست داریم می‌توانیم با استفاده از آرگومان دوم متد index، نام مورد علاقه‌ی خودمان را تحمیل کنیم.

	$table->index(['last_name','first_name'] , 'index_name');

#### ایندکس یکتا

ایندکس‌های یکتا با متد unique() تعریف می‌شوند و هر چه برای ایندکس‌های معمولی گفتیم، در ایندکس‌های یکتا نیز به کار می‌آیند.

می‌توانیم آن‌ها را به صورت زنجیره‌ای در انتهای همان خط تعریف ستون، تعریف نماییم:

	$table->string('username')->unique();

می‌توانیم پس از تعریف ستون، در خطی مستقل آن‌ها را تعریف کنیم:

	$table->unique('username');

و می‌توانیم با استفاده از آرگومان دوم، نام دلخواه خودمان را به آن تحمیل کنیم.

	$table->unique('username','unique_username');

#### ایندکس اصلی

پیش از این، روش ثبت primary index را آموختیم و گفتیم که بهتر است به همان سنت مألوف چنگ بیاندازیم و اولین فیلد را به این شکل (دقیقاً به این شکل) تعریف کنیم:

	$table->increments('id');

اگرچه همین تک‌خط همه‌ی کارهای ما را راه می‌اندازد، اما بد نیست اشاره کنیم که ثبت ایندکس اصلی نیز با روش‌هایی که برای ایندکس‌های معمولی و یکتا گفتیم امکان‌پذیر است.

می‌توانیم از روش زنجیره‌ای برای تعریف آن استفاده کنیم:

	$table->unsignedInteger('id')->autoIncrement();

می‌توانیم در خط جداگانه‌ای تعریفش کنیم:

	$table->unsignedInteger('id');
	$table->primary('id');

و می‌توانیم چند فیلد را با یکدیگر ترکیب نماییم:

	$table->primary(['id','parent_id']);

#### کلیدهای خارجی

فرض کنید جدولی از دیدگاه‌ها داریم که هر دیدگاه توسط یکی از کاربران ارسال شده است. بیایید برای این کار یک ستون user_id بسازیم و به id در جدول users متصلش کنیم.

	$table->integer('user_id')->unsigned();
	$table->foreign('user_id')->references('id')->on('users');

حتی این موضوع که در صورت پاک شدن رکورد اصلی چه اتفاقی برای رکورد مرتبط می‌افتد را نیز می‌توانید در مایگرشن تعیین کنید.

	$table->foreign('user_id')
	->refrences('id')
	->on('users')
	->onDelete('cascade');

## ویرایش یک جدول

اصول کلی ویرایش جدول هم درست مثل تولید آن است، با اندکی جزئیات اضافه که با هم مرورشان می‌کنیم.

#### تولید فایل مایگرشن

برای ماگریشن ویرایشی هم از آرتیزان کمک می‌گیریم و باز هم از همان دستوری که قبلاً آموختیم استفاده می‌کنیم.

	php artisan add_folan_to_vessels_table

فایلی که این بار لاراول می‌سازد نیز همان رنگ و بو و ساختار قبلی را دارد، با اندکی تفاوت. تشخیصش می‌دهید؟

``` php
<?php // 2018_01_13_182854_add_folan_to_vessels_table
  use Illuminate\Support\Facades\Schema;
  use Illuminate\Database\Schema\Blueprint;
  use Illuminate\Database\Migrations\Migration;
  class AddDescriptionToVesselsTable extends Migration
  {
  /**
  * Run the migrations.
  * @return void
  */
    public function up()
    {
      //
    }
  /**
  * Reverse the migrations.
  * @return void
  */
    public function down()
    {
      //
    }
  }
```

امیدوارم پیش از مطالعه‌ی این سطر، مندرجات فایل تولیدشده به این روش را با فایلی که قبلاً تولید کردیم مقایسه کرده و متوجه تفاوت شده باشید.

داستان از این قرار است که این بار متدهای up و down خالی هستند و عرصه را به ما واگذاشته‌اند و این در حالی است که ما هیچ کار خاصی نکردیم، جز این که از کلمه‌ی create در نام فایلی که می‌خواستیم بسازیم استفاده نکردیم.

#### و حالا کمی بهتر...

با ارسال چند پارامتر به دستور آرتیزان ساخت فایل مایگرشن، می‌‌توانیم لاراول را در ساخت بهتر فایل اولیه راهنمایی کنیم.

	php artisan make:migration add_description_to_vessels_table --table=vessels

در این دستور، به لاراول می‌گوییم که قصد داریم فایلی با عنوان add_description_to_vessels_table بسازیم و در آن تغییراتی به جدول vessels دهیم.

فایلی که به این ترتیب ایجاد می‌شود، به اندازه‌ی فایل قبلی خالی نیست، چرا که این بار لاراول می‌داند با کدام جدول کار داریم و دستور اسکیمای لازم را نوشته و تنها باید closureهای هر دو متد up و down را مطابق با نیازمان تکمیل کنیم.

``` php
<?php // 2018_01_12_182854_add_description_to_vessels_table
  use Illuminate\Support\Facades\Schema;
  use Illuminate\Database\Schema\Blueprint;
  use Illuminate\Database\Migrations\Migration;
  class AddDescriptionToVesselsTable extends Migration
  {
  /**
  * Run the migrations.
  * @return void
  */
    public function up()
    {
      Schema::table('vessels', function (Blueprint $table) {
        //
      });
    }
  /**
  * Reverse the migrations.
  * @return void
  */
    public function down()
    {
      Schema::table('vessels', function (Blueprint $table) {
        //
      }
    }
  }
```

#### تغییر در ستون‌ها

همه‌ی متدهایی که برای ساخت جداول معرفی کردیم، اینجا نیز کار می‌کنند. تفاوت ماجرا اینجاست که لازم است بتوانیم محل ستون‌های جدیدی که به ستون‌های قبلی اضافه می‌شوند را تعیین کنیم، هرچند که اجباری نیست و اگر چنین نکنیم، ستون‌ها به انتهای جدول پیشین اضافه می‌شوند.

	$table->tinyText('description')->after('text');

متد after در دستور بالا، ستون description را پس از ستون text قرار می‌دهد.

	$table->tinyText('description')->first();

متد first در دستور بالا، ستون جدید را در ابتدای جدول می‌نشاند (که البته کار عاقلانه‌ای نیست، چون بنا بر پاره‌ای روایات، اول جدول‌ها جای ستون id است).

	$table->renameColumn('from','to');

متد renameColumn یکی از ستون‌ها را تغییر نام می‌دهد، اما به صورت پیش‌فرض در لاراول قابل اجرا نیست و برای استفاده، به پکیج doctrine/dbal نیاز دارید. نحوه‌ی نصب پکیج‌ها را در همین کتاب خواهیم آموخت.

	$table->dropColumn('active')

متد dropColumn که در سطر بالا استفاده شده، یکی از ستون‌ها را از بین می‌برد. این متد، آرایه هم می‌پذیرد و می‌توانید چند ستون را هم‌زمان از بین ببرید. متأسفانه این متد در دیتابیس SQLite به صورت پیش‌فرض پشتیبانی نمی‌شود و پکیجی که در بالا معرفی کردیم را نیاز خواهید داشت. اما در دیتابیس‌های دیگر بدون پکیج نیز قابل استفاده است.

#### تغییر در ایندکس‌ها

متدهای اضافه کردن ایندکس را مرور کردیم و همان‌ها اینجا هم کار می‌کنند. شاید به چند متدی که برای حذف ایندکس‌ها استفاده می‌شوند نیاز داشته باشید. لاراول متدهای زیر را ارائه می‌کند که از نامشان پیداست چه می‌کنند و به چه کار می‌آیند:

	$table->dropPrimary('users_id_primary');
	$table->dropUnique('users_email_unique');
	$table->dropIndex('geo_state_index');
	$table->dropForeign('posts_user_id_foreign');

همه‌ی این متدها از ورودی آرایه نیز پشتیبانی می‌کنند تا چندین ایندکس را هم‌زمان حذف کنند.

## متد down

نوشتن متد down برای بسیاری ابهام دارد، اما منطق کار آن قدر ساده است که هر نوع ابهامی عجیب به نظر می‌رسد.

داستان از این قرار است که می‌بایست هر کار در متد up کردید را در متد down برعکس کنید. دستور migrate در کنسول آرتیزان، فایل‌های مایگرشن را یکی یکی و به ترتیب نامشان برمی‌گیرد و متدهای up را در آن‌ها اجرا می‌کند. در نقطه‌ی مقابل، دستور migrate:rollback و سایر دستورهای بازگشتی در کنسول آرتیزان، فایل‌های مایگرشن را یکی یکی و به با ترتیبی برعکس نامشان برمی‌گیرند و متدهای down را در آن‌ها اجرا می‌کنند.

به بیان ساده‌تر، فلسفه‌ی مایگرشن آن است که ساخت و ساز جداول را به چرخه‌ی حیات برنامه بیاورد و این کار فقط با تکمیل درست متدهای down به صورت کامل میسر می‌شود. دستپاچه و هراسان نشوید. همه‌ی کاری که قرار است بکنید همین است: 

هرچه در متد up نوشتید را در متد down برعکس کنید.

هرچه در متد up ساختید را در متد down ویران کنید و هرچه در متد up ویراش کردید را در متد down به حال نخست بازگردانید.

اگر در متد up جدولی ساخته‌اید، باید در متد down آن را drop کنید و این درست کاری است که استفاده از دستور ساخت مایگرشن به کمک آرتیزان، به آن نحو که در ابتدای این درس توضیح دادیم، خودبه‌خود انجام می‌دهد.

``` php
public function down()
{
  Schema::dropIfExists('vessels');
}
```

اگر در متد up ویرایشی را روی جدولی انجام دادید، یا ستون‌های جدیدی ساختید، در متد down آن ویرایش‌ها را به حال نخست بازگردانید و ستون‌های جدیدی که ساخته‌اید را دور بریزید. ساخت مایگرشن به کمک آرتیزان، به آن نحو که در بخش «ویرایش یک جدول» این درس گفتیم، چنین کاری را به صورت پیش‌فرض انجام نمی‌دهد (چون نمی‌تواند حدس بزند که در متد up چه نوشته‌اید) و خودتان باید زحمتش را بکشید.

این آخری، نیازمند یک مثال است. فرض کنید مایگرشنی نوشته‌ایم که دو ستون در جدول vessels اضافه کند.

``` php
<?php // 2018_01_13_182854_add_folan_to_vessels_table
  use Illuminate\Support\Facades\Schema;
  use Illuminate\Database\Schema\Blueprint;
  use Illuminate\Database\Migrations\Migration;
  class AddDescriptionToVesselsTable extends Migration
  {
  /**
  * Run the migrations.
  * @return void
  */
    public function up()
    {
      Schema::table('vessels', function (Blueprint $table) {
        $table->string('folan')->after('text');
        $table->boolean('bisar');
      });
    }
  /**
  * Reverse the migrations.
  * @return void
  */
    public function down()
    {
      Schema::table('vessels', function (Blueprint $table) {
        $table->dropColumn(['folan','bisar']);
      });
    }
  }
```

به این ترتیب، دستورات migration در مسیر رفت متد up را اجرا می‌کنند و ستون‌های مورد نظر را به جدولی که از پیش وجود داشته (یا در مایگرشن قبلی ساخته شده) اضافه می‌کنند و در مسیر برگشت، متد down را اجرا می‌کنند و دو ستون اضافه‌شده را دور می‌اندازند و همه چیز به حالت قبل بازمی‌گردد.

## تکرار یک هشدار

باز هم دقت کنید. اجرای دستورهای مایگرشن، فقط در فاز توسعه‌ی برنامه انجام می‌شود و خودتان باید مراقب اطلاعاتی که با حذف یک ستون یا جدول دور ریخته می‌شود باشید. لاراول نمی‌تواند حدس بزند که واقعاً آن داده‌ها را لازم دارید یا نه، اما می‌تواند مراقب باشد که در فاز بهره‌برداری از دستور migrate استفاده نکنید. 
اگر چنین کنید، اخطاری می‌گیرید.

![](_images/03-03-02.png)

## آپولو هوا کنیم

